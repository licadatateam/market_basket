# -*- coding: utf-8 -*-
"""goparts_marketBasket.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Cv03gEYt2M4P2Y07tsegUZEM2Odgg7aX

**To do**
---

Optimize rules - support, confidence, lift \\
Visualize result - how? best? \\
More than1 antecedent \\
association of group of products \\
Application - marketing, supply and logistics, website experience \\
reporting \\
more general items (product categories, sku only)

**Install and import packages**
---
Pandas \\
Numpy \\
Pyplot \\
Seaborn \\
Apriori \\
Plotly \\
Networkx \\
"""

import pandas as pd
from mlxtend.frequent_patterns import association_rules, apriori
import networkx as nx
import plotly.graph_objects as go
import plotly
import math
from itertools import cycle
import streamlit as st
#from io import BytesIO

st.set_page_config(layout="wide",
                    page_title='Market Basket Analysis',
                    page_icon=":convenience_store:",
                    initial_sidebar_state='expanded',
                    menu_items = {
                         'About':"# Thanks for using the app!\n For inquiries, send an email to Arvin Escolano at arvinjayescolano.licagroup@gmail.com."
                        })


st.title("""**Market Basket Analysis**""")

category_dict = {"bulbs":"Accessories","car care combiset":"Accessories","early warning device":"Accessories",
              "universal horn": "Accessories","wipers":"Accessories","air filter":"Air Induction & Exhaust",
              "cabin filter or aircon filter":"Air Induction & Exhaust","brake drum":"Brakes System",
              "brake fluid":"Brakes System","brake fluid dot 4":"Brakes System",
              "brake pads":"Brakes System","brake parts cleaner":"Brakes System",
              "brake paste":"Brakes System","brake shoe":"Brakes System",
              "rotor disc":"Brakes System","adhesive and silicone": "Various Chemicals",
              "alternator belt":"Engine System","atf": "Engine System",
              "axle oil":"Engine System","ball joint assembly": "Suspension System",
              "battery": "Ignition System","center link assembly":"Suspension System",
              "coolant": "Engine System","cvt": "Engine System","cvtf":"Engine System",
              "drive belt":"Engine System","engine flush": "Engine System","engine oil": "Engine System",
              "fan belt": "Engine System","fuel filter":"Fuel System","gear oil": "Engine System",
              "glow plug":"Ignition System","grease":"Engine System","idler arm assembly":"Suspension System",
              "lubricant or cleaner":"Various Chemicals","lubrication system":"Lubrication System",
              "motor assembly":"Cooling System","oil filter":"Lubrication System",
              "pitman arm assembly":"Suspension System","power steering belt":"Engine System",
              "power steering fluid":"Engine System","sealant":"Various Chemicals",
              "shock absorber":"Suspension System","shock mounting":"Suspension System",
              "silicone spray":"Various Chemicals","spark plugs":"Ignition System",
              "stabilizer link or rod":"Suspension System","steering rack end":"Suspension System",
              "tie rod end":"Suspension System","timing belt":"Engine System",
              "transmission fluid":"Engine System", "clutch disc":"Transmission System"
              }
to_fix_category_name = {"Vortex": "engine oil","VortexPlus": "engine oil", "Powerplus":"brake drum",
                        "Aisin":"clutch disc","Federal":"ball joint assembly","Shell":"engine oil","Kia":"brake parts cleaner",
                        "Wiper":"wipers","Bendix":"brake fluid","Oem":"car care combiset",
                        "ACDelco":"engine oil","Usa":"engine oil"}
to_fix_brand= { "Vortex":"Vortex Plus", "VortexPlus":"Vortex Plus", "Wiper":"ACDelco",
               "Oem":"OEM Engineering","Usa":"USA88", "Powerplus":"Power Plus","Federal":"Federal Mogul"}

def convert_df(df):
     # IMPORTANT: Cache the conversion to prevent computation on every rerun
     return df.to_csv().encode('utf-8')

def find_rules(df_temp, transaction_id, segmentation, min_s = 10, disp = False,quantity = 'quantity'):
  df_basket = pd.DataFrame()
  df_basket = df_temp[[transaction_id, segmentation, quantity]].copy()
  df_basket_items = df_basket.groupby([transaction_id,segmentation])[quantity].sum().unstack(1).reset_index().set_index(transaction_id)
  basket_items = (df_basket_items.notnull()).astype('bool')
  frequent_itemsets = apriori(basket_items, min_support= min_s/100, use_colnames=True, max_len = 5)
  rules = association_rules(frequent_itemsets, metric="leverage",  min_threshold = 0)
  rules["antecedents"] = rules["antecedents"].apply(lambda x: ', '.join(list(x))).astype("unicode")
  rules["consequents"] = rules["consequents"].apply(lambda x: ', '.join(list(x))).astype("unicode")
  rules['hover_name'] = rules['antecedents'] +"\u2192" + rules['consequents']
  rules["antecedent"] = rules["antecedents"].copy()
  return df_basket_items, rules

def bar_hist(df_test, seg, prob, cat = 'id'):

  fig = go.Figure()
  total_count = df_test.groupby(cat)[seg].count().sum()
  if prob:
    title_text = "Probability"
    df = df_test.groupby(seg)[cat].apply(lambda x:100* x.count()/total_count).sort_values(ascending =False)
  else:
    title_text = "Actual Order Count"
    df = df_test.groupby(seg)[seg].apply(lambda x: x.count()).sort_values(ascending =False)
  fig.add_trace(
    go.Bar(x=df.index,
          y=df,
          visible = True,
          text =df.index,
          textposition = 'outside'))
  seg = segment_dict[seg]
  fig.update_layout(template = 'simple_white',title_text= title_text+" of "+seg+"s Being Bought per Basket",bargap=0.05, width = 1000, height = 500)
  if prob:
    ya_text = 'Probability (%)'
  else:
    ya_text = 'Count (units)'
  fig.update_yaxes(title_text = ya_text,showline=True, linewidth=1, linecolor='black', mirror=True, ticks ='inside',range = [0,df.max()*1.1])
  fig.update_xaxes(title_text = seg,showline=True, linewidth=1, linecolor='black', ticks ='',mirror=True,range = [-0.5,9.5], rangeslider=dict(visible=True),showticklabels=False)
  
  return df, fig

def hist(df_test, is_prob = True, is_count = True, step = 1):
  df_data=pd.DataFrame()
  df_test = df_test[['id','quantity','cost']].copy()
  total_count = df_test['id'].nunique()
  if is_count:
    df_data['quantity'] = df_test.groupby('id')['quantity'].sum().apply(lambda x: math.ceil(x/step)*step)
    df = df_data.groupby('quantity')['quantity'].count()
    t_text = "Market Basket Item Count"
    x_title = "Basket Item Count"
  else:
    df_data['cost'] = df_test.groupby('id')['cost'].sum().apply(lambda x: math.ceil(x/step)*step)
    df = df_data.groupby('cost')['cost'].count()
    t_text = "Market Basket Price"
    x_title = "Basket Price"

  fig = go.Figure()
  if is_prob:
    title_text = "Probability"
    df = round(100 * df/total_count,2)
    suff = "%"
    ya_text = 'Probability (%)'
  else:
    title_text = "Actual Order Count"
    suff = ""
    ya_text = 'Count (# of baskets)'
  fig.add_trace(
    go.Bar(x=df.index,
          y=df,
          visible = True,
          text = df.apply(lambda x: str(x)+suff),
          textposition = 'outside'))
  fig.update_layout(template = 'simple_white',title_text= t_text + "("+ title_text+")" ,bargap=0.05)
  fig.update_yaxes(title_text = ya_text,showline=True, linewidth=1, linecolor='black', mirror=True, range = [0,df.max()*1.1] )#autorange = True
  fig.update_xaxes(title_text = x_title,showline=True, linewidth=1, linecolor='black', mirror=True,range = [0.5*step,(10.5)*step], rangeslider=dict(visible=True),showticklabels=True)
  return fig

def df_to_plotly(df):
    return {'z': df.values.tolist(),
            'x': df.columns.tolist(),
            'y': df.index.tolist()}
def heatmap_ac(rulesAll):
  df_heatmap = rulesAll.groupby(['antecedents', 'consequents'])['confidence'].apply(lambda x: round(x.unique().item()*100,2)).fillna(0).unstack(1).reset_index().set_index('antecedents')
  df_heatmap_ = rulesAll.groupby(['antecedents', 'consequents'])['confidence'].apply(lambda x: round(x.unique().item()*100,2)).fillna(0).unstack(1).reset_index().set_index('antecedents')
  df__ = df_to_plotly(df_heatmap)
  
  fig = go.Figure()
  
  fig.add_trace(go.Heatmap(df__,
                  text = df_heatmap_.fillna("0"),
                  texttemplate="%{text}",
                  hoverongaps = False,
                  ))
  fig.update_xaxes(title_text = 'consequent',tickson='boundaries',showline=True, linewidth=1, linecolor='black', mirror=True, ticks='', showgrid=True)
  fig.update_yaxes(title_text = 'antecedent',tickson='boundaries',showline=True, linewidth=1, linecolor='black', mirror=True, ticks='', showgrid=True,autorange='reversed')
  fig.update_layout(template='simple_white', title_text = "Correlation Heatmap between Antecedents and Consequents", width = 1150, height = 700)
  st.plotly_chart(fig)

def xy_scatter(df_temp,segment, item_x,item_y, set_vis=True):
  df_temp = df_temp.set_index('hover_name')
  df_temp[['support','antecedent support','consequent support','confidence']] =df_temp[['support','antecedent support','consequent support','confidence']].apply(lambda x:x*100) 
  colors = cycle(plotly.colors.sequential.Viridis)
  fig = go.Figure()
  for seg in df_temp[segment].unique():
    fig.add_trace(
        go.Scatter(
            x = df_temp.loc[df_temp[segment]== seg][item_x],
            y = df_temp.loc[df_temp[segment]== seg][item_y],
            mode = 'markers',
            marker = dict(
                size = df_temp['lift']/df_temp['lift'].max()*30,
                color = df_temp['lift']
            ),
            visible = set_vis,
            name = seg,
            marker_color =next(colors),
            hovertemplate = list(df_temp.loc[df_temp[segment]== seg].index)
        )
    )
  fig.update_layout(legend=dict(
      yanchor="top",
      y=0.99,
      xanchor="left",
      x=1.01,
      title = segment
  ))

  fig.update_layout(template = 'simple_white',title_text= item_y+" vs. "+item_x)
  fig.update_yaxes(title_text = item_y+" (%)",showline=True, linewidth=1, linecolor='black', mirror=True, ticks = 'inside')
  fig.update_xaxes(title_text = item_x+" (%)",showline=True, linewidth=1, linecolor='black', mirror=True, ticks = 'inside')
  st.plotly_chart(fig)

def basket_network_plot(rules, plot_title = 'Insert Plot Title', clean = False):
  G=nx.from_pandas_edgelist(rules,source='antecedents',target='consequents', edge_attr=True)
  pos = nx.drawing.layout.spring_layout(G)
  nx.set_node_attributes(G, pos, 'pos')

  if clean:
    mode_plot = 'markers'
  else:
    mode_plot = 'markers+text'

  edge_x = []
  edge_y = []
  for edge in G.edges():
      x0, y0 = G.nodes[edge[0]]['pos']
      x1, y1 = G.nodes[edge[1]]['pos']
      edge_x.append(x0)
      edge_x.append(x1)
      edge_x.append(None)
      edge_y.append(y0)
      edge_y.append(y1)
      edge_y.append(None)

  edge_trace = go.Scatter(
      x=edge_x, y=edge_y,
      line=dict(width=1, color='#888'),
      hoverinfo='none',
      mode='lines')

  node_x = []
  node_y = []
  for node in G.nodes():
      x, y = G.nodes[node]['pos']
      node_x.append(x)
      node_y.append(y)

  node_trace = go.Scatter(
      x=node_x, y=node_y,
      mode=mode_plot,
      text = node_x,
      textposition = 'bottom center',
      hoverinfo='text',
      marker=dict(
          showscale=True,
          colorscale='YlGnBu',
          reversescale=True,
          color=[],
          size=25,
          opacity = 1,
          colorbar=dict(
              thickness=10,
              title='Lift',
              xanchor='left',
              titleside='right'
          ),
          line_width=2))

  node_adjacencies = []
  node_text = []
  node_size = []
  see = []
  for node, adjacencies in enumerate(G.adjacency()):
      confidence = round(pd.DataFrame.from_dict(adjacencies[1]).iloc[:,0].loc['confidence']*100,2)
      lift = round(pd.DataFrame.from_dict(adjacencies[1]).iloc[:,0].loc['lift']*100,2)
      n_adjacencies = len(adjacencies[1])
      node_adjacencies.append(lift)
      if n_adjacencies != 1:
        node_text.append(str(adjacencies[0])+' (Support='+str(round(pd.DataFrame.from_dict(adjacencies[1]).iloc[:,0].loc['antecedent support']*100,2)) + '%)')#('['+str(n_adjacencies)+'] '+str(adjacencies[0])+': '+str(c_support) + '%')
      else:
        node_text.append(str(adjacencies[0])+' (Confidence: '+str(confidence) + '%)')
      node_size.append(n_adjacencies)
      see.append(adjacencies)

  node_trace.marker.color = node_adjacencies
  node_trace.text = node_text
  node_trace.marker.size = 15#[(x/max(node_size))*25 for x in node_size]

  fig = go.Figure(data=[edge_trace, node_trace], #text = 'a',
              layout=go.Layout(template = 'simple_white',
                  title= plot_title,
                  titlefont_size=18,
                  showlegend=False,
                  hovermode='closest',
                  margin=dict(b=20,l=5,r=5,t=40),
                  xaxis=dict(showgrid=False, zeroline=False, showticklabels=False,showline=True, linewidth=1, linecolor='black', mirror=True,ticks = '', range =[-1.25,1.25]),
                  yaxis=dict(showgrid=False, zeroline=False, showticklabels=False,showline=True, linewidth=1, linecolor='black', mirror=True,ticks = '', range =[-1.25,1.25]))
                  )
  st.plotly_chart(fig)

def merged_rules(df_temp):
    AllRules = pd.DataFrame()
    segmentation = ['product_desc','brand','product_category','brand_category']
    for segment in segmentation:
      rules =pd.DataFrame()
      itemsAll, rules = find_rules(df_temp, 'id', segment, 2)
      AllRules = pd.concat([AllRules,rules],axis=0)
    AllRules.loc[:,'antecedents'] = AllRules.loc[:,'antecedents'].apply(lambda x: ', '.join(sorted(x.split(', '))))
    return AllRules

def find_suggestions(df, item,confidence,support):
  if (df==item).any().sum()>0:
    seg = (df==item).any()[(df==item).any()==True].index[0]
    sugg_list = df.loc[df[seg]==item].sort_values(by = 'percentage',ascending = False)
    sugg_list = sugg_list[['product_desc',seg,'percentage']]
    sugg_list.columns = ['SKU',seg,'percentage']
    sugg_list.loc[:,'confidence'] = confidence
    sugg_list.loc[:,'support'] = support
    return sugg_list
  else:
    return pd.DataFrame()

def matching_sequence(df_p, rules,input_list):  
  available_sugg = []
  corr_sugg = []
  df_match = pd.DataFrame()
  matching_df = pd.DataFrame()
  suggestion_data = pd.DataFrame()
  product_category_sugg = pd.DataFrame()
  brand_category_sugg = pd.DataFrame()
  brand_sugg = pd.DataFrame()
  SKU_sugg = pd.DataFrame()
  ldata = [pd.DataFrame(),pd.DataFrame(),pd.DataFrame(),pd.DataFrame(),pd.DataFrame(),pd.DataFrame(),pd.DataFrame()]
  for sku in input_list:
    df_match = df_p.loc[df_p['product_desc'].isin(input_list)]
  matching_df.loc['product_desc','match'] = ', '.join(df_match['product_desc'].sort_values().unique())
  matching_df.loc['brand'] = ', '.join(df_match['brand'].sort_values().unique())
  matching_df.loc['product_category'] = ', '.join(df_match['product_category'].sort_values().unique())
  matching_df.loc['brand_category'] = ', '.join(df_match['brand_category'].sort_values().unique())
  matching_df = matching_df.transpose()
  mdf = matching_df.values
  consequents_df = rules.loc[rules['antecedents'].isin(list(mdf[0]))].sort_values(by='confidence', ascending = False)
  for item in consequents_df['consequents'].unique():
    confidence = round(consequents_df.loc[consequents_df['consequents']==item,'confidence'].item()*100,2)
    support =round(consequents_df.loc[consequents_df['consequents']==item,'support'].item()*100,2)
    suggestions = find_suggestions(df_p, item, confidence,support)
    if len(suggestions)>0:
      suggestion_data = pd.concat([suggestion_data,suggestions])
  not_req = ['SKU','percentage','confidence','support']
  cols = suggestion_data.columns
  lmask = ~pd.Series(cols).isin(not_req)
  for i in range(len(cols)):
    if lmask[i]:
      ldata[i] = suggestion_data.groupby(cols[i],as_index=False).first().sort_values(by='confidence', ascending=False).set_index('SKU').dropna(axis=1)
  for df in ldata:
    if len(df) >0:
      available_sugg.append(df.columns[0])
      corr_sugg.append(df)
  if 'product_desc' in available_sugg:
    SKU_sugg = corr_sugg[available_sugg.index('product_desc')]
  if 'brand' in available_sugg:
    brand_sugg = corr_sugg[available_sugg.index('brand')]
  if 'brand_category' in available_sugg:
    brand_category_sugg = corr_sugg[available_sugg.index('brand_category')]
  if 'product_category' in available_sugg:
    product_category_sugg = corr_sugg[available_sugg.index('product_category')]

  return SKU_sugg,brand_sugg,brand_category_sugg,product_category_sugg,matching_df

def scatter_explore():
  fig = go.Figure()
  fig.add_trace(
      go.Scatter(x = df_explore['count'],
                y = df_explore['total_cost'],
                mode = 'markers',
                hovertext = df_explore['id'].astype(str) #+'\n'+df_explore['items']
                )
  )
  fig.update_xaxes(title_text = 'Basket Count',showline=True, linewidth=1, linecolor='black', mirror=True, range = [0,df_explore['count'].max()*1.1])
  fig.update_yaxes(title_text = 'Basket Price',showline=True, linewidth=1, linecolor='black', mirror=True,range = [0,df_explore['total_cost'].max()*1.1])
  fig.update_layout(template = 'simple_white')
  st.plotly_chart(fig)

@st.experimental_memo()
def gather_data():
    df_raw = pd.read_csv("http://app.redash.licagroup.ph/api/queries/118/results.csv?api_key=nVfPq3pxbOF6uSWOlCI8HQSRmgMb34OD6tWvrapY", parse_dates = ['created_at'])
    df_raw = df_raw.loc[df_raw['quantity']>0]
    df_raw = df_raw.loc[:,['id', 'created_at','GarageId','product_desc', 'garage_type', 'brand', 'category_name','quantity','price']]
    df_raw.columns = ['id', 'date','garage_id','product_desc', 'garage_type', 'brand', 'category_name','quantity','price']
    df_raw = df_raw.loc[df_raw['price']>0]
    df_raw.loc[df_raw.category_name.isnull(),'brand'] = df_raw.loc[:,'product_desc'].apply(lambda x:x.split(" ")[0])
    df_raw.loc[df_raw.category_name.isnull(),'category_name'] = df_raw.loc[df_raw.category_name.isnull(),'brand'].apply(lambda x: to_fix_category_name[x])
    df_raw.loc[df_raw['brand'].isin(list(to_fix_brand.keys())),'brand'] = df_raw.loc[df_raw['brand'].isin(list(to_fix_brand.keys())),'brand'].apply(lambda x: to_fix_brand[x])
    df_raw['product_category'] = df_raw['category_name'].apply(lambda x: category_dict[x])
    df_raw['category_name'] = df_raw['product_category']
    df_raw['brand_category'] = [str(x) + ' '+str(y).title() for (x,y) in zip(df_raw['brand'], df_raw['product_category'])]
    df_raw['cost'] = df_raw['quantity']*df_raw['price']
    
    df_product = pd.DataFrame()
    df_product = df_raw.loc[:,['brand','product_desc','product_category','brand_category']].groupby('product_desc', as_index=False).first()
    df_product = df_product.sort_values(by=['brand','product_desc'],ascending = [True, True]).set_index('product_desc')
    df_product['item_count'] = df_raw.groupby('product_desc')['quantity'].sum()
    df_product['percentage'] = 100*df_product['item_count']/df_product['item_count'].sum()
    df_product = df_product.reset_index()
    
    
    return df_raw, df_product

def exploration_data(df_raw):
    df_explore = df_raw.groupby('id').agg(count = ('quantity', lambda x: x.sum()),
                         total_cost = ('cost',lambda x: round(x.sum(),2)),
                         items = ('product_desc',lambda x: ', '.join(x.unique()))).reset_index()
    return df_explore

df_raw, df_product = gather_data()

section = st.sidebar.selectbox('Select Section:', ('Market Basket Simulation','Data Exploration', 'Basket Budget', 'Product Association'))

segments = ['Brand','Category','Category_Brand','SKU']
segments_ = ['product_desc','brand','category_name','brand_category']
segment_dict = {'product_desc':'SKU',
                'brand':'Brand',
                'category_name':'Category',
                'brand_category':'Category_Brand'}
segment_dict_ = {v: k for k, v in segment_dict.items()}

garage_type = st.sidebar.selectbox(
label = 'Select considered garages:',
options =('All','Rapide', 'Non-Rapide', 'Non-B2C', 'B2C'))
if st.sidebar.button("Reset Data"):
    st.experimental_memo.clear()
    df_raw = pd.DataFrame()

if garage_type =='Non-Rapide':
  df_raw = df_raw.loc[df_raw['garage_type'] != 'rapide_service_center' ]
elif garage_type == 'Rapide':
  df_raw = df_raw.loc[df_raw['garage_type'] == 'rapide_service_center' ]
elif garage_type == 'Non-B2C':
  df_raw = df_raw.loc[~df_raw['garage_type'].isin(['rapide_service_center','Inactive'])]
elif garage_type == 'B2C':
  df_raw = df_raw.loc[df_raw['garage_type']== 'Inactive']


data_exploration = st.empty()
with data_exploration.container():
    
    st.header('Data Exploration')
    cA, cB = st.columns([1,3])
    with cA:
        st.markdown("#### Controls")
        seg = st.selectbox('Select Segmentation', segments)
        is_prob = st.radio("Data presentation: ", ('Probability','Actual Count'),  horizontal=True)
        df_out_, fig_de = bar_hist(df_raw,segment_dict_[seg], is_prob=='Probability','id')     
    with cB:
        st.plotly_chart(fig_de)
    cD, cE = st.columns([1,1])
    with cD:
        count_step = st.number_input('Step for basket count:', 1, 100, 1)
        fig_count = hist(df_raw, is_prob=='Probability', True,step = count_step)
        st.plotly_chart(fig_count)
    with cE:
        price_step = st.number_input('Step for basket price:', 100, 10000, 1000)
        fig_price = hist(df_raw, is_prob=='Probability', False,step = price_step)
        st.plotly_chart(fig_price)
    df_out_ = df_out_.to_frame('count/probability')
    st.markdown("""### Download data:""")
    csv_save_ = convert_df(df_out_)
    st.download_button(
                        label="data_exploration.csv",
                        data=csv_save_,
                        file_name='data_exploration.csv',
                        mime='text/csv'
                        )
    st.caption('Data for data exploration (Product segment vs. item count/probability).')
if section != 'Data Exploration':
     data_exploration.empty() 
     
basket_budget = st.empty()   
with basket_budget.container():
    st.markdown("""#### Basket Budget""")   
    Ec, Fc, Gc = st.columns([1,5,1]) 
    with Fc:
        df_explore = exploration_data(df_raw)
        scatter_explore()
    st.markdown("""### Download data:""")
    csv_save__ = convert_df(df_explore)
    st.download_button(
                        label="basket_budget.csv",
                        data=csv_save__,
                        file_name='basket_budget.csv',
                        mime='text/csv'
                        )
    st.caption('Data for basket budget (Price vs. item count).')
if section != 'Basket Budget':
     basket_budget.empty()     


association_analysis= st.empty()
with association_analysis.container():
    st.header('Market Basket Association Analysis')
    cF, cG, cF2= st.columns([1,5,1])
    st.sidebar.markdown("""---""")
    st.sidebar.markdown("""Market Basket Analysis Controls""")
    segmentation = st.sidebar.selectbox('Select Segmentation:', segments)
    clean = st.sidebar.checkbox('Clean network plot ', value=False)
    
    s_segmentation = segment_dict_[segmentation]   
    itemsAll, rulesAll = find_rules(df_raw, 'id', s_segmentation, 2) 
    selection = rulesAll.columns   
    
    with cG:
        filter_rules = st.expander('Filter rules', expanded =False)
        with filter_rules:
            a_list =  rulesAll['antecedents'].unique().tolist()
            beta_multiselectA = st.container()
            check_all = st.checkbox('Select all antecedents', value=True)
            if check_all:
                selected_antecedents = beta_multiselectA.multiselect('Included suppliers in table:',
                                               options = a_list,
                                               default = a_list)
            else:
                selected_antecedents = beta_multiselectA.multiselect('Included suppliers in table:',
                                               options = a_list)
            rulesAll = rulesAll.loc[rulesAll['antecedents'].isin(selected_antecedents)]
            
            c_list =  rulesAll['consequents'].unique().tolist()
            beta_multiselectB = st.container()
            check_all = st.checkbox('Select all consequents', value=True)
            if check_all:
                selected_consequents = beta_multiselectB.multiselect('Included suppliers in table:',
                                               options = c_list,
                                               default = c_list)
            else:
                selected_consequents = beta_multiselectB.multiselect('Included suppliers in table:',
                                               options = c_list)
            rulesAll = rulesAll.loc[rulesAll['consequents'].isin(selected_consequents)]    
        if len(rulesAll)>0:
    
            heatmap_ac(rulesAll)
            show_rules = st.expander('Show all data', expanded =False)
            with show_rules:
                st.write(rulesAll.drop(columns = ['hover_name', 'antecedent', 'leverage', 'conviction']))
        else:
            st.markdown("""### No product associations have been established based on segment.""")
    
    set_vis = True
    segment = 'antecedent'
    cI, cJ = st.columns([1,1])
    with cI:
        item_y = st.selectbox('y-axis', selection, index = 5)
        item_x = st.selectbox('x-axis', selection, index = 4)
        xy_scatter(rulesAll,segment, item_x,item_y, set_vis)
    with cJ:
        filter_network = rulesAll['antecedents'].unique()
        s_filter = item_x = st.selectbox('x-axis', filter_network, index = 0)
        basket_network_plot(rulesAll.loc[rulesAll['antecedents']==s_filter], 'Category Association',clean) #.str.contains('NGK',na=False)
    
    AllRules = merged_rules(df_raw)
    cK, cL, cM = st.columns([3,5,3])
    with cL:
        basket_network_plot(AllRules, 'Product Associations', clean)
    st.markdown("""### Download data:""")
    csv_save = convert_df(rulesAll)
    st.download_button(label="heatmap_data.csv",
                        data=csv_save,
                        file_name='heatmap_data.csv',
                        mime='text/csv')
    st.caption('Data for heatmap (Confidence of Antecedent vs. Consequent).')
    st.markdown(""" --- """)
    AllRules_ = convert_df(AllRules)
    st.download_button(label="all_rules.csv",
                        data=AllRules_,
                        file_name='all_rules.csv',
                        mime='text/csv')
    st.caption('Data for the acquired association rules.')
if section != 'Product Association':
     association_analysis.empty()    

simulation= st.empty()
with simulation.container():
    st.header("Market Basket Simulation")
    
    def show_metric(df,seg, a):
        if len(df)>0:
            df = df.reset_index()
            for sku in df['SKU']:
                antecedent = a[seg].item()
                consequent = df_product.loc[df_product['product_desc'] == sku][seg].item()
                st.metric(label = antecedent+"\u2192" +consequent,value = sku,delta = "Confidence: "+str(df.loc[df['SKU']==sku,'confidence'].item())+"%")
        else:
            st.caption('No suggestions for this section.')
    df_product = df_product.sort_values(by = 'percentage', ascending = False)
    input_list = st.multiselect('Basket items:',options = df_product['product_desc'].unique())
    if len(input_list)> 0:
        cs,cN,cO,cs = st.columns([1,3,7,1])
        SKU_sugg, brand_sugg, brand_category_sugg, product_category_sugg,list_summary=matching_sequence(df_product, AllRules,input_list)
        with cN:
            #st.write(pd.DataFrame(input_list,columns=['Item']).merge(df_product.iloc[:,:3], left_on ='Item', right_on='product_desc',how='inner').drop('product_desc', axis=1))
            st.markdown("#### Selected Items:")
            st.markdown("""---""")
            for item in input_list:
                st.markdown(f"""
                            - **{item}**
                            """)
            st.markdown("""---""")
        with cO:
            t1, t2, t3, t4, t5 = st.tabs(["All","By SKU", "By Brand/Category", "By Product Category","By Brand"])
            with t1:
                st.markdown("""##### Suggestions based on SKU.""")
                show_metric(SKU_sugg,'product_desc',list_summary)
                st.write("""---""")
                st.markdown("""##### Suggestions based on brand/category.""")
                show_metric(brand_category_sugg,'brand_category',list_summary)
                st.write("""---""")
                st.markdown("""##### Suggestions based on product category.""")
                show_metric(product_category_sugg,'product_category',list_summary)
                st.write("""---""")
                st.markdown("""##### Suggestions based on brand.""")
                show_metric(brand_sugg,'brand',list_summary)
            with t2:
                st.markdown("""##### Suggestions based on SKU.""")
                st.write("""---""")
                show_metric(SKU_sugg,'product_desc',list_summary)
            with t3:
                st.markdown("""##### Suggestions based on brand/category.""")
                st.write("""---""")
                show_metric(brand_category_sugg,'brand_category',list_summary)
            with t4:
                st.markdown("""##### Suggestions based on product category.""")
                st.write("""---""")
                show_metric(product_category_sugg,'product_category',list_summary)
            with t5:
                st.markdown("""##### Suggestions based on brand.""")
                st.write("""---""")
                show_metric(brand_sugg,'brand',list_summary)
        
    else:
        st.info('Start Shopping Now!')
if section != 'Market Basket Simulation':
    simulation.empty()







# st.header("Download data")
# def extract_data(df):
#     output = BytesIO()
#     writer = pd.ExcelWriter(output, engine='xlsxwriter')
#     df_SKU = find_rules(df, 'id', 'product_desc', 2)
    
#     df_product_category = find_rules(df, 'id', 'product_category', 2) 
    
#     df_brand_category = find_rules(df, 'id', 'brand_category', 2) 
#     df_brand = find_rules(df, 'id', 'brand', 2) 
#     df_brand.to_excel(writer, index=False, sheet_name='by_brand')
#     st.write('1')
#     df_product_category.to_excel(writer, index=False, sheet_name='by_product_category')
#     st.write('2')
#     df_brand_category.to_excel(writer, index=False, sheet_name='by_brand_category')
#     st.write('3')
#     df_SKU.to_excel(writer, index=False, sheet_name='by_SKU') 
#     st.write('4')
#     workbook = writer.book
#     worksheet = writer.sheets['by_SKU','by_product_category','by_brand_category','by_brand']
#     format1 = workbook.add_format({'num_format': '0.00'}) 
#     worksheet.set_column('A:A', None, format1)  
#     writer.save()
#     processed_data = output.getvalue()
#     return processed_data
# st.write(type(df_raw_))
# df_out = extract_data(df_raw_)
# st.download_button(label='📥 Download Current Result',
#                                 data=df_out,
#                                 file_name= 'website_template.xlsx')

